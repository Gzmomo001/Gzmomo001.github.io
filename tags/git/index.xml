<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Git on Henry Zhang</title>
        <link>https://Gzmomo001.github.io/tags/git/</link>
        <description>Recent content in Git on Henry Zhang</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>henryzhang070&#43;contact@gmail.com</copyright>
        <lastBuildDate>Wed, 26 Nov 2025 18:15:34 +0800</lastBuildDate><atom:link href="https://Gzmomo001.github.io/tags/git/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Git</title>
        <link>https://Gzmomo001.github.io/p/git/</link>
        <pubDate>Tue, 25 Nov 2025 17:43:06 +0800</pubDate>
        
        <guid>https://Gzmomo001.github.io/p/git/</guid>
        <description>&lt;img src="https://Gzmomo001.github.io/p/git/git.png" alt="Featured image of post Git" /&gt;&lt;h2 id=&#34;hook&#34;&gt;Hook
&lt;/h2&gt;&lt;p&gt;想象你写了一晚上的论文, 但是不小心被小组成员改坏了. 或者debug发现bug越来越多以至于无法修复, 整个项目基本要推倒重来. 上诉这种类似的情况其实屡见不鲜. 不只是计算机专业的同学会遇到, 其他非专业同学在编辑ppt, word, 或者设计工程图的时候也一样会遇到类似的问题. 而git的出现就是为了解决这一类的问题.&lt;/p&gt;
&lt;h2 id=&#34;feature&#34;&gt;Feature
&lt;/h2&gt;&lt;p&gt;git 作为版本控制工具最基本的功能就是管理文件版本. 可以将每一次文件的修改都记录起来. 当项目发生不可挽回的错误的时候. 只要.git文件夹还在就能发动败者食尘功能直接将时间会回滚到上一次提交的时候. 除此之外还提供了团队协作的功能. 不同的团队成员可以在同一个仓库下的不同brach对项目进行迭代又不会相互影响.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Gzmomo001.github.io/p/git/jojos-killer.gif&#34;
	width=&#34;464&#34;
	height=&#34;258&#34;
	srcset=&#34;https://Gzmomo001.github.io/p/git/jojos-killer_hu4835421799670992788.gif 480w, https://Gzmomo001.github.io/p/git/jojos-killer_hu18354979973675417943.gif 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;败者食尘&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;179&#34;
		data-flex-basis=&#34;431px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考视频&#34;&gt;参考视频
&lt;/h2&gt;&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;iframe loading=&#34;lazy&#34; 
            src=&#34;https://www.youtube.com/embed/vA5TTz6BXhY&#34; 
            allowfullscreen 
            title=&#34;YouTube Video&#34;
    &gt;
    &lt;/iframe&gt;
&lt;/div&gt;

&lt;h2 id=&#34;quick-start&#34;&gt;Quick start
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# ubuntu/debian&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;apt install git
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# mac&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;brew install git
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Configuration&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git config --global user.name &lt;span class=&#34;s2&#34;&gt;&amp;#34;Your Name&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git config --global user.email &lt;span class=&#34;s2&#34;&gt;&amp;#34;your.email@example.com&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#initialization | it will create a hidden folder which is called .git&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git init
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;common-command&#34;&gt;Common command
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# check status&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git status
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# add all file of this folder&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git add .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# simple commit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git commit -m &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;lt;commit info&amp;gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# check commit history | type q to quit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git log
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# connet to remote repository | orgin: set the name of the remote repo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git remote add origin &amp;lt;url of remote repository&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# switch to the main branch&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git branch -M main
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# push to the remote repo | when you use git push it will push to the defualt repo that your pulled before.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git push -u origin main &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; git push
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# pull the latest version of the remote repo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git pull
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;[!NOTE]
.gitignore: you can create a this file and fill the files or dict that you do not want to push on remote.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# add all the changes to the this commit and commit it with only one line code&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git commit -am &lt;span class=&#34;s2&#34;&gt;&amp;#34;args&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# clone a remote repo | clone a remote repo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone &amp;lt;url&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# fetch&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git fetch &amp;lt;url&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当你要使用私有远程仓库的时候,就需要验证你的个人信息,确保你有权利访问这个远程仓库. 这个时候就需要使用ssh生成一对密钥对, 然后将公钥放在远程仓库上. 有关这方面的知识如果不是很明白可以先去学学ssh相关的内容.&lt;/p&gt;
&lt;h2 id=&#34;advance-command--feature&#34;&gt;Advance command &amp;amp; feature
&lt;/h2&gt;&lt;h3 id=&#34;git-checkout&#34;&gt;git checkout
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;切换分支 | 创建切换到新分支&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git checkout -b &amp;lt;branch_name&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 创建并移动到新分支&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git branch &amp;lt;branch_name&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git checkout &amp;lt;branch_name&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 这两行等等效上面这行&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;放弃当前未保存的修改&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git checkout -- &amp;lt;file_name&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 放弃该文件的修改并回滚到上一次提交的状态&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;查看历史提交&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git checkout -b &amp;lt;commit_id&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 提交历史id 可以通过git log 查看或者gui查看&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;git-stash&#34;&gt;git stash
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git stash
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git stash save &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;lt;comment&amp;gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 存档当前的更改并回到最新一次提交的状态 | archive the modification and roll back to the latest commit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git stash list
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git stash list 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 查看存档&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git stash pop stash@&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&amp;lt;id&amp;gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git stash pop stash@&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&amp;lt;id&amp;gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git stash pop
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 将缓存剪切出来&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git stash apply stash@&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&amp;lt;id&amp;gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git stash apply stash@&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&amp;lt;id&amp;gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git stash apply
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 将缓存复制出来&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git stash clear
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#清空缓存&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;git-reset&#34;&gt;git reset
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;git reset&lt;/code&gt; 命令用于将当前分支的HEAD指针重置到指定的提交状态。它有三种常用模式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 撤销最后一次的提交&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git reset --soft HEAD~1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 软重置 - 保留工作区和暂存区的更改&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git reset --soft &amp;lt;commit_id&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 仅移动HEAD指针到指定提交，不改变工作区和暂存区&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 混合重置(默认) - 保留工作区更改，但清空暂存区&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git reset --mixed &amp;lt;commit_id&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 或者简写为&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git reset &amp;lt;commit_id&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 移动HEAD指针，并重置暂存区，但保留工作区更改&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 硬重置 - 丢弃所有更改&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git reset --hard &amp;lt;commit_id&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 移动HEAD指针，重置暂存区和工作区，丢弃所有更改&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;撤销最近的提交&lt;/li&gt;
&lt;li&gt;合并多个提交为一个&lt;/li&gt;
&lt;li&gt;彻底撤销错误的更改&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;git-merge--官方文档httpsgit-scmcomdocsgit-merge&#34;&gt;git merge | &lt;a class=&#34;link&#34; href=&#34;https://git-scm.com/docs/git-merge&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文档&lt;/a&gt;
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt; 命令用于将一个或多个分支的更改合并到当前分支：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 合并指定分支到当前分支&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git merge &amp;lt;branch_name&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 创建合并提交，即使快进合并可用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git merge --no-ff &amp;lt;branch_name&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 合并时产生一个squash提交，不保留原分支的提交历史&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git merge --squash &amp;lt;branch_name&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;git-rebase--官方文档httpsgit-scmcomdocsgit-rebase&#34;&gt;git rebase | &lt;a class=&#34;link&#34; href=&#34;https://git-scm.com/docs/git-rebase&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文档&lt;/a&gt;
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;git rebase&lt;/code&gt; 用于将一系列提交“变基”到另一个基础提交上。通俗地说，它会把你的提交历史“移动”到另一个分支的最新提交之后，使得提交历史看起来更线性、更整洁。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 将当前分支的提交应用到 &amp;lt;base_branch&amp;gt; 的顶部&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git rebase &amp;lt;base_branch&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 例如，你在 feature 分支上，想把 main 分支的最新更改合并进来&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git checkout feature
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git rebase main
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;交互式 Rebase (&lt;code&gt;-i&lt;/code&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个非常强大的功能，允许你修改、合并、重新排序或删除一系列提交。e.g. 在某一个提交中有一个提交没有意义需要删除中间的某个提交.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 重新整理最近的3个提交&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git rebase -i HEAD~3
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;执行后会打开一个编辑器，显示这3个提交，你可以执行以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pick&lt;/code&gt;：保留提交（默认）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reword&lt;/code&gt;：修改提交信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edit&lt;/code&gt;：修改提交内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;squash&lt;/code&gt;：将该提交与前一个提交合并&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fixup&lt;/code&gt;：与 &lt;code&gt;squash&lt;/code&gt; 类似，但丢弃该提交的提交信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;drop&lt;/code&gt;：删除提交&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;git-merge-vs-git-rebase&#34;&gt;Git Merge vs. Git Rebase
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt; 和 &lt;code&gt;git rebase&lt;/code&gt; 是两种将一个分支的更改集成到另一个分支的主要方法。它们的核心区别在于如何处理提交历史。&lt;/p&gt;
&lt;h4 id=&#34;git-merge&#34;&gt;Git Merge
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;保留历史&lt;/strong&gt;：&lt;code&gt;merge&lt;/code&gt; 会保留原始分支的完整、精确的提交历史。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合并提交&lt;/strong&gt;：它会在目标分支上创建一个新的“合并提交”，这个提交有两个父提交，分别指向两个被合并的分支。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非线性历史&lt;/strong&gt;：这会导致提交历史图谱看起来像一个分叉再汇合的图形，可以清晰地看到分支从哪里来，又在哪里合并。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：简单直接，保留了真实的开发轨迹，便于追溯。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：如果分支活动频繁，合并提交会非常多，导致主分支历史变得混乱。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;git-rebase&#34;&gt;Git Rebase
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;重写历史&lt;/strong&gt;：&lt;code&gt;rebase&lt;/code&gt; 会找到两个分支的共同祖先，然后将当前分支的所有提交“重放”（replay）到目标分支的顶部。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线性历史&lt;/strong&gt;：它会创建一个线性的、干净的提交历史，看起来就像所有开发都是在一条直线上完成的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：历史记录非常整洁，没有不必要的合并提交，易于阅读和理解。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;重写了历史&lt;/strong&gt;：这可能会使追溯问题变得困难，因为它改变了提交的原始上下文。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;风险&lt;/strong&gt;：&lt;strong&gt;永远不要在已经推送到远程并被团队成员使用的公共分支上使用 &lt;code&gt;rebase&lt;/code&gt;&lt;/strong&gt;。因为这会为团队其他成员造成历史记录不一致的问题，导致严重的协作混乱。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结
&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;&lt;code&gt;git merge&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;git rebase&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;历史记录&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;非线性，保留分叉&lt;/td&gt;
&lt;td&gt;线性，整洁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;易用性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;简单，不易出错&lt;/td&gt;
&lt;td&gt;相对复杂，有风险&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;协作&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;安全，适合公共分支&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;危险&lt;/strong&gt;，只应在私有分支上使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;结果&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;产生一个合并提交&lt;/td&gt;
&lt;td&gt;不产生合并提交，但会创建新的提交&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;何时使用？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;git merge&lt;/code&gt; 将功能分支合并到 &lt;code&gt;main&lt;/code&gt; 或 &lt;code&gt;develop&lt;/code&gt; 等主分支上。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;git rebase&lt;/code&gt; 在将你的功能分支合并到主分支之前，用来同步主分支的最新更改，保持你的分支历史干净。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;冲突处理-conflict-resolution--官方文档httpsgit-scmcombookzhv2git-e5b7a5e585b7-e9ab98e7baa7e59088e5b9b6&#34;&gt;冲突处理 (Conflict Resolution) | &lt;a class=&#34;link&#34; href=&#34;https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文档&lt;/a&gt;
&lt;/h3&gt;&lt;p&gt;在使用 Git 进行合并 (&lt;code&gt;git merge&lt;/code&gt;) 或变基 (&lt;code&gt;git rebase&lt;/code&gt;) 操作时，如果两个分支修改了同一个文件的同一部分，或者一个分支修改了文件而另一个分支删除了它，Git 无法自动解决这些差异，就会发生“冲突”（Conflict）。&lt;/p&gt;
&lt;h4 id=&#34;如何识别冲突&#34;&gt;如何识别冲突
&lt;/h4&gt;&lt;p&gt;当冲突发生时，Git 会停止当前操作并通知你。你可以通过 &lt;code&gt;git status&lt;/code&gt; 命令查看哪些文件处于冲突状态。&lt;/p&gt;
&lt;p&gt;在冲突的文件中，Git 会插入特殊的标记来指示冲突的部分：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 这是你当前分支（HEAD）的更改
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;=======
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 这是你正在合并（或变基）的分支的更改
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; branch-name-or-commit-id
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD&lt;/code&gt; 到 &lt;code&gt;=======&lt;/code&gt; 之间的内容是当前分支（你的工作）的更改。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=======&lt;/code&gt; 到 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; branch-name-or-commit-id&lt;/code&gt; 之间的内容是你正在合并/变基的分支（传入的更改）的更改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;解决冲突的步骤&#34;&gt;解决冲突的步骤
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;识别冲突文件&lt;/strong&gt;：运行 &lt;code&gt;git status&lt;/code&gt; 检查哪些文件有冲突。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;手动编辑文件&lt;/strong&gt;：打开每个冲突文件，手动修改内容，决定保留哪些更改、丢弃哪些更改，或者如何组合它们。在解决完冲突后，&lt;strong&gt;务必删除&lt;/strong&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;、&lt;code&gt;=======&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 这些冲突标记。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;暂存已解决的文件&lt;/strong&gt;：对每个解决冲突后的文件运行 &lt;code&gt;git add &amp;lt;filename&amp;gt;&lt;/code&gt; 将其标记为已解决。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完成操作&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果是 &lt;code&gt;git merge&lt;/code&gt;&lt;/strong&gt;：在所有冲突都解决并暂存后，运行 &lt;code&gt;git commit&lt;/code&gt; 完成合并。Git 会自动生成一个合并提交信息，你可以修改它。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果是 &lt;code&gt;git rebase&lt;/code&gt;&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;解决冲突并暂存后，运行 &lt;code&gt;git rebase --continue&lt;/code&gt; 继续变基过程。&lt;/li&gt;
&lt;li&gt;如果你决定放弃当前的变基操作并回到变基前的状态，可以运行 &lt;code&gt;git rebase --abort&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;常用辅助命令&#34;&gt;常用辅助命令
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git merge --abort&lt;/code&gt;：在合并过程中，如果你觉得冲突太复杂，想放弃合并并回到合并前的状态，可以使用此命令。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git rebase --abort&lt;/code&gt;：在变基过程中，如果你想放弃变基并回到变基前的状态，可以使用此命令。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git mergetool&lt;/code&gt;：配置并使用外部合并工具（如 Kdiff3, Beyond Compare, VS Code 等）来图形化地解决冲突。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout --ours &amp;lt;filename&amp;gt;&lt;/code&gt;：如果你想保留当前分支对 &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; 的所有更改，而丢弃传入分支的更改。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout --theirs &amp;lt;filename&amp;gt;&lt;/code&gt;：如果你想保留传入分支对 &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; 的所有更改，而丢弃当前分支的更改。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]
记住，解决冲突是一个需要仔细和耐心的过程&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
