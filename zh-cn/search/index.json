[{"content":"软连接 在系统中我们往往可能需要在一个项目中使用项目之外的一些文件，但是这个文件又不在这项目的根目录在。大部分人往往都选择直接将需要的文件拷贝到项目的路目中。但是这样既浪费时间又浪费系统的存储空间。尔软连接的出现就是为了解决这一问题。我们可以直接通过命令创建一个软连接。让目标文件或者文件夹的替身出现在我们的项目目录下。这样我们就可以在不使用绝对路径的情况下使用该路径了。\n如何使用软连接（ln 在 linux 中软连接的是由\u0026rsquo;ln\u0026rsquo;这一指令完成的。\n在 linux 我们可以使用\u0026rsquo;man ln\u0026rsquo;就能查看 ln 的使用手册 这里列举一些常用的\u0026rsquo;ln\u0026rsquo; 命令\n# Create a symbolic link to a file or directory: # 会在路标路径下创建一个原路径同名的文件或者文件夹 ln --symbolic /path/to/file_or_directory path/to/symlink #Overwrite an existing symbolic link to point to a different file: ln --symbolic --force /path/to/new_file path/to/symlink # Create a hard link to a file: ln /path/to/file path/to/hardlink # Delete a symbolic link: rm path/to/symlink 如果链接是相对路径，那这个相对是路径应该是相对于软连接目标目录的路径 ###官方文档链接\n","date":"2025-07-31T15:38:14+08:00","image":"http://localhost:1313/p/soft_links/link_hu_7de80d1bc2b06914.png","permalink":"http://localhost:1313/zh-cn/p/soft_links/","title":"Soft_links"},{"content":"继承 和 多态(java) 这个章节是基于类的延伸\n子类和父类 在 java 中有一个关键字叫 \u0026rsquo;extends\u0026rsquo;，意思是扩展， 这个关键字可以定义一个类的延伸类, 并具有所有原先类的方法(method)和变量(data field)。\nfor example: 定义一个类叫 person, 那么他的子类就可以是学生, 老师, 员工等.\n这样定义有什么好处吗? 当你已经使用了一个类完成某项代码任务的时候, 有其他的代码也需要用到这个类 但是这个类中的某些东西方法需要改变, 或者有些变量需要增加的时候, 你就可以在不改变原来的类的情况下创建一个子类, 对子类进行修改来完成新的任务. 通过这样的方法可以大大减少代码的冗余.提高代码的复用性. 具体实现 public class Person { private String name; private int age; private String gender; public Person(String name, int age, String gender) { this.name = name; this.age = age; this.gender = gender; } } public class Student extends Person { private String major; public Student(String name, int age, String gender, String major) { super(name, age, gender); // 在这里, 我们的super keyword 的作用就是调用父类的构造器. this.major = major; } } 如果这里的构造器没有调用父类的构造器, 那么编译器会会在编译的时候在该构造器的最前面先调用父类的无参构造器. 当父类使用 final 关键字的时候, 则无法定义其子类 转型 在 Java 中，类型转换主要分为两种：向上转型（upcasting）和向下转型（downcasting）。 转型可以改变原有实例的 data field. 但同时也伴随着风险.\n向上转型（Upcasting） 向上转型是将子类类型转换为父类类型，这种转换是自动的、安全的。因为子类一定包含父类的所有特性。\nMethod: 如果子类重写方法则使用重写之后的方法. Data Field: 保留父类的变量, 但是不能使用子类的变量. 应用场景 当你需要子类的方法的时候但是却不需要子类的变量的时候. // 向上转型示例 Student student = new Student(\u0026#34;张三\u0026#34;, 20, \u0026#34;男\u0026#34;, \u0026#34;计算机科学\u0026#34;); Person person = student; // 自动向上转型 // 或者显式写法 Person person2 = (Person)student; // 效果相同 当子类想临时使用父类的某个方法的时候可以仿照这个例子调用: \u0026ldquo;((father)child).method();\u0026rdquo;\n向下转型（Downcasting） 能够向下转型的几种情况.\nnew 类的时候使用的是子类, 但是当作了父类来使用. 或者在继承类上转换, 例如: person -\u0026gt; faculty -\u0026gt; teacher 这三个类. 当 new 的类是 teacher, 但是被当作 person 使用的时候, 那 person 类就能转型为 faculty. // 向下转型示例 Person person = new Student(\u0026#34;李四\u0026#34;, 19, \u0026#34;女\u0026#34;, \u0026#34;数学\u0026#34;); // 首先向上转型 Student student = (Student)person; // 向下转型 // 错误的向下转型示例 Person person2 = new Person(\u0026#34;王五\u0026#34;, 25, \u0026#34;男\u0026#34;); Student student2 = (Student)person2; // 运行时会抛出 ClassCastException // 转型前错误检查能有效避免运行错误 if (person instanceof Student) { // instanceof这个关键字能检查实例是否属于某个指定的类. Student student = (Student)person; System.out.println(\u0026#34;专业：\u0026#34; + student.getMajor()); } else { System.out.println(\u0026#34;这个人不是学生\u0026#34;); } 关于 \u0026ldquo;instanceof\u0026rdquo; 关键字: 检查的是该类在创建时的 new 的类是否属于某个类链条上.\nNest class | 嵌套类(非大纲) 作用 可以避免多个顶层类. 可以将一些只在外部类中使用的类封装在外部类中. 比如, 只有学生这个类需要课程表这个类, 那么这个类就只需要在学生类下定义. 内部类 (Inner Class) 能够访问外部类的所有成员. public class OuterClass { private String msg = \u0026#34;Hello\u0026#34;; // 非静态内部类 class InnerClass { public void display() { // 可以访问外部类的所有成员 System.out.println(msg); } } } 静态嵌套类 (Static Nested Class) 静态嵌套类不能直接访问内部的静态成员. 当前示例代码中的静态子类就无法访问num这个变量. 静态嵌套类虽然无法访问外部类的非静态成员, 但是可以访问该类内部的成员. 比如示例代码中的a. public class OuterClass { private static String msg = \u0026#34;Hello\u0026#34;; private int num = 10; // 静态嵌套类 static class StaticNestedClass { int a = 10; public void display() { // 可以访问外部类的静态成员 System.out.println(msg); } } } Overriding Methods | 方法重写 当一个学生类想要调用toString方法输出自己的信息的时候, person类的toString方法可能并没有涉及到学生类新data field, 比如年纪, 学号等. 这个时候就是方法重写大展拳脚的时候了.\n在子类中, 我们可以使用@Override签名来重写父类的方法. 这样做的好处是: 拒绝冗余的方法定义: 我们可以在不变动父类方法的情况下创建一个新的方法来实现相同的功能. 但是父类的方法就会继承到子类中, 造成代码的冗余. 同时当我们调用方法的时候, 也会造成调用格式不统一的问题. class father{ void methodA{ System.out.println(\u0026#34;This is A\u0026#34;) } } class children{ @override // 其实这里不使用这个签名方法也能顺利重写, 但为了代码规范还是建议在重写的方法前添加这个签名 void methodA{ System.out.println(\u0026#34;This is also A\u0026#34;) } } 比如之前章节学的, 当我们使用wrapper class的时候, 不管是什么类型的类, 我们都可以使用相同的compareTo方法.\n方法重写的前提是父类的方法没有使用 final 关键字. 使用 final 关键字的方法无法被子类重写, 这样做可以防止一些关键的方法被错误的重写, 能让子类的代码更加规范.\nOverriding vs. Overloading 方法重写 方法重写是子类对与父类的方法的重新定义\n方法重载 方法重载是多个相同签名的方法, 但是在调用的时候会根据传入的参数类型和数量来决定使用哪个方法.\nObject Class | 对象类 在 java 中所有的类都是 object class 的子类\ntoString method 不考试的同学可以跳过本章节, 博主认为这个方法没有特别的作用, 了解一下就好.\n这是所有对象都包含的一个方法.\n调用后会显示一些关于这个类的信息. 信息的构成为\u0026lt;实例名称\u0026gt;@\u0026lt;哈希值\u0026gt;\n当你使用 print 直接打印的类的时候, 类就会自动调用这个方法然后返回字符串.\n多态 这个章节主要讲类可以作为一个参数传入方法中使用.\nDynamic Binding | 动态绑定 前文提到的方法签名统一的好处就体现在这里.\n当我们按照之前的代码规范重写代码, 保持方法签名的统一的时候. 我们就能在方法中使用相同的方法签名来调用不同类中相同功能的方法, 而不需要提前规定好方法只能接受哪种类. equals method 在原始的对象类中, 这个方法会对比对象的内存地址是否相同.\n实际中的作用 由于这个方法签名比较常用. 所以很多时候, 如果我们想要自定义某个类的该方法, 我们就会重写这个方法.\n== vs. equals 在 equals 方法没有被重写的时候, 我们有: \u0026lsquo;==\u0026rsquo; \u0026gt; \u0026rsquo;equals\u0026rsquo;的结论. 因为双等号除了能对比对象地址外还能比较基本变量的值.\n重写规范 当你重写这个方法的时候传入的参数一定是 object 类. 示例:\n@override public boolean equals(Object circle) { return this.radius == ((Circle)circle).radius; } The ArrayList Class 容量是动态的 创建 // 创建一个空的 ArrayList ArrayList\u0026lt;String\u0026gt; list1 = new ArrayList\u0026lt;\u0026gt;(); // 创建一个指定初始容量的 ArrayList ArrayList\u0026lt;Integer\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(10); // 从其他集合创建 ArrayList ArrayList\u0026lt;Double\u0026gt; list3 = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(1.1, 2.2, 3.3)); \u0026lsquo;\u0026lt;\u0026gt;\u0026lsquo;是泛型, 目前知道知道括号里填什么类型的 wrapper 类, 这个数组就会存储什么类型的变量.\nadd // 在列表末尾添加元素 list.add(element); // 返回 boolean // 在指定位置插入元素 list.add(index, element); // void 返回 // 添加多个元素 list.addAll(collection); // 返回 boolean list.addAll(index, collection); // 返回 boolean visit // 获取指定位置的元素 Element element = list.get(index); // 获取第一次出现的位置 int index = list.indexOf(element); // 获取最后一次出现的位置 int lastIndex = list.lastIndexOf(element); modify // 替换指定位置的元素 Element oldElement = list.set(index, newElement); delete // 删除指定位置的元素 Element removedElement = list.remove(index); // 删除第一次出现的指定元素 boolean isRemoved = list.remove(element); // 删除所有元素 list.clear(); query // 检查是否包含某个元素 boolean contains = list.contains(element); // 检查是否为空 boolean isEmpty = list.isEmpty(); // 获取列表大小 int size = list.size(); transfer // 转换为数组 Object[] array = list.toArray(); String[] stringArray = list.toArray(new String[0]); // 获取子列表（视图） List\u0026lt;E\u0026gt; subList = list.subList(fromIndex, toIndex); sort // 排序（使用自然顺序） Collections.sort(list); // 使用自定义比较器排序 Collections.sort(list, comparator); // 反转列表 Collections.reverse(list); 这个类并不线程安全, 这意味着当多个线程同时操作这个类的时候可能会出现一些问题. 另外虽然这个类的容量的可变的, 但还是尽量在一开始就把容量定义好. 因为当类需要自己扩增容量的时候会影响性能.\n","date":"2025-05-24T21:05:41+08:00","image":"http://localhost:1313/java.png","permalink":"http://localhost:1313/zh-cn/p/chapter11/","title":"Chapter11"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"http://localhost:1313/helena-hertz-wWZzXlDpMog-unsplash.jpg","permalink":"http://localhost:1313/zh-cn/p/test-chinese/","title":"Chinese Test"}]